{"version":3,"sources":["timeUtils/regex-util.ts","timeUtils/time-math.ts","timeUtils/time-test-util.ts","timeUtils/time-parser.ts","components/Display/Display.tsx","components/button-colors.ts","components/ControlButtons/ControlButtons.tsx","components/ButtonGrid/ButtonGrid.tsx","components/Calculator.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["digitOnlyRegex","TimeMath","operation","type","OperationType","DURATION_AND_DURATION","value","this","evaluateDurationAndDuration","expression","TimeType","DURATION","POINT_AND_DURATION","evaluatePointAndDuration","TIMESTAMP","POINT_TO_POINT","evaluatePointToPoint","expresion","value1","operator","value2","TimeOperator","PLUS","Date","getTime","MINUS","TO","HOUR","convertStrToTokens","str","tokens","digitOrColonRegex","token","char","test","OPERATOR_TOKENS","includes","push","MINUTE","tokenToString","output","i","length","TimeParser","is24hrTime","enable","input","time","outputStr","parsedExpression","parseExpression","evaluate","formatOutput","parsedExpressionArray","expressionArray","parseTokens","strVal1","strVal2","strVal3","expressionType","parsedTimeValue1","getParsedTime","parsedOperator","getParsedOperator","parsedTimeValue2","timeVal","formatDurationOutput","formatTimestampOutput","strVal","hoursStr","minutesStr","valueStr","skipChars","parseInt","timeOnlyStr","isPM","today","now","indexOf","replace","minutes","timeStrArray","split","hours","setHours","isValidDurationStr","isValidTimestampStr","timeStr","after","addToSection","colonCount","hoursToInt","minutesToInt","isNaN","values","units","val","duration","negativeSign","Math","abs","floor","remainder","hoursSubstr","minutesSubtr","timestamp","date","getHours","getMinutes","concat","toString","suffix","terms","currentTerm","getTimeType","getDuration","getTimestamp","operatorStr","Display","inputValue","outputValue","DisplayWrapper","DisplayInput","onChange","DisplayOutput","styled","div","BaseInput","BTN_GREEN","BTN_TEXT_ACTIVE","ControlButtons","updateInput","toggle24hrTime","ControlButtonWrapper","TimeControlButton","disabled","isActive","onClick","DurationControlButton","NowControlButton","ControlButton","button","btnColors","props","buttonColor","ButtonsArray","displayString","color","callback","removeInput","clearInput","confirm","ButtonGrid","ButtonGridWrapper","map","btnConfig","Button","BackButton","BackSymbol","Calculator","useState","setInputValue","setOutputValue","setIs24hrTime","timeParserRef","useRef","current","useEffect","set24hrTime","handleUpdateInput","CalculatorWrapper","slice","evaluateExpression","displayName","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f97913ec.chunk.js","sourcesContent":["export const digitOnlyRegex = /^\\d+$/;","import { ParsedOperation, ParsedExpression, OperationType, TimeOperator, TimeType, Time, HOUR } from './time-parser';\n\nexport class TimeMath {\n  static evaluate(operation: ParsedOperation): Time | null {\n    switch (operation.type) {\n      case OperationType.DURATION_AND_DURATION: {\n        const value = this.evaluateDurationAndDuration(operation.expression);\n        return value == null ? value : {\n          value,\n          type: TimeType.DURATION\n        };\n      }\n      case OperationType.POINT_AND_DURATION: {\n        const value = this.evaluatePointAndDuration(operation.expression);\n        return value == null ? value : {\n          value,\n          type: TimeType.TIMESTAMP\n        };\n      }\n      case OperationType.POINT_TO_POINT: {\n        const value = this.evaluatePointToPoint(operation.expression);\n        return value == null ? value : {\n          value,\n          type: TimeType.DURATION\n        };\n      }\n      default:\n        return null;\n    }\n  }\n\n  // timepoint +/- duration = timepoint\n  // Ex: 5:00pm + 2hr = 7:00pm (output UTC timestamp in ms)\n  static evaluatePointAndDuration(expresion: ParsedExpression): number | null {\n    const [value1, operator, value2] = expresion;\n    if (operator === TimeOperator.PLUS) {\n      return new Date(value1.value + value2.value).getTime();\n    }\n\n    if (operator === TimeOperator.MINUS) {\n      return new Date(value1.value - value2.value).getTime();\n    }\n\n    return null;\n  }\n\n  // duration +/- duration = duration\n  // Ex: 5hr + 30min = 5hr30min (output in ms)\n  static evaluateDurationAndDuration(expression: ParsedExpression): number | null {\n    const [value1, operator, value2] = expression;\n    if (operator === TimeOperator.PLUS) return value1.value + value2.value;\n    if (operator === TimeOperator.MINUS) return value1.value - value2.value;\n    return null;\n  }\n\n  // timepoint to timepoint = duration\n  // Ex 4:00pm to 5:30pm = 1hr30min (output in ms)\n  static evaluatePointToPoint(expression: ParsedExpression): number | null {\n    const [value1, operator, value2] = expression;\n    if (operator !== TimeOperator.TO) return null;\n    if (value2.value >= value1.value) {\n      return value2.value - value1.value;\n    }\n    // if time 2 is earlier than time 1 assume calculating to that time the next day\n    // ie 11:00pm to 1:00am = 2hrs NOT -22hrs\n    return (24 * HOUR + value2.value) - value1.value;\n  }\n}","import { OPERATOR_TOKENS } from './time-parser';\n\nexport function getMockDateNowTimestamp(): number {\n  return new Date('January 1, 1980, 13:00:00 UTC').getTime();\n}\n\nexport function convertStrToTokens(str: string): string[] {\n  const tokens = [];\n  // digits (0-9) or colon (:)\n  const digitOrColonRegex = /^\\d|:+$/;\n\n  // multicharacter tokens:\n  // to\n  // now\n  // am\n  // pm\n  // hr\n  // min\n\n  let token = '';\n  for (let char of str) {\n    if (char === ' ') {\n      continue;\n    }\n    if (digitOrColonRegex.test(char) || OPERATOR_TOKENS.includes(char)) {\n      tokens.push(char);\n      continue;\n    }\n\n    token += char;\n\n    if (\n      token === 'to' ||\n      token === 'now' ||\n      token === 'am' ||\n      token === 'pm' ||\n      token === 'hr' ||\n      token === 'min'\n    ) {\n      tokens.push(token);\n      token = '';\n    }\n  }\n  return tokens;\n}","import { digitOnlyRegex } from './regex-util';\nimport { TimeMath } from './time-math';\nimport { convertStrToTokens } from './time-test-util';\n\n// time in ms\nexport const SECOND = 1000;\nexport const MINUTE = 60 * SECOND;\nexport const HOUR = 60 * MINUTE;\n\n// msOffset from Today 00:00:00 current TMZ -- how to get this? \n\n// new Date(msOffset +/- duration) -- provides new time point\nexport enum TimeType {\n  DURATION = 'duration',\n  TIMESTAMP = 'timestamp',\n}\n\nexport enum TimeOperator {\n  PLUS = '+',\n  MINUS = '-',\n  TO = 'to'\n}\n\nexport enum OperationType {\n  POINT_AND_DURATION = 'POINT_AND_DURATION',\n  DURATION_AND_DURATION = 'DURATION_AND_DURATION',\n  POINT_TO_POINT = 'POINT_TO_POINT',\n}\n\nexport interface Time {\n  value: number, // ms\n  type: TimeType,\n}\n\nexport type ParsedExpression = [Time, TimeOperator, Time];\n\nexport interface ParsedOperation {\n  expression: ParsedExpression, \n  type: OperationType,\n}\n\nexport const OPERATOR_TOKENS = [\n  TimeOperator.TO as string, \n  TimeOperator.PLUS as string, \n  TimeOperator.MINUS as string\n];\n\nexport function tokenToString(tokens: string[]): string {\n  let output = ''\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (OPERATOR_TOKENS.includes(token)) {\n      output += ` ${token} `;\n    } else {\n      output += token;\n    }\n  }\n  return output;\n}\n\nexport class TimeParser {\n  public is24hrTime: boolean;\n\n  constructor(is24hrTime: boolean = false) {\n    this.is24hrTime = is24hrTime;\n  }\n\n  public set24hrTime(enable: boolean) {\n    this.is24hrTime = enable;\n  }\n\n  // this is the method used by the view to go from raw token input to string output\n  public evaluateExpression(input: string[]): string {\n    const parsedExpression = this.parseExpression(input);\n    let time;\n    let outputStr;\n    if (parsedExpression) {\n      time = TimeMath.evaluate(parsedExpression);\n    }\n    if (time) {\n      outputStr = this.formatOutput(time);\n    }\n    return outputStr ?? 'Invalid Input';\n  }\n\n  public parseExpression(input: string[]): ParsedOperation | null {\n    const parsedExpressionArray: [Time?, TimeOperator?, Time?] = [];\n    let expressionArray = this.parseTokens(input);\n    if (expressionArray == null) {\n      return null;\n    }\n\n    const [strVal1, strVal2, strVal3] = expressionArray;\n    if (!strVal1 || !strVal2 || !strVal3) {\n      return null;\n    }\n    const parsedTimeValue1 = this.getParsedTime(strVal1);\n    const parsedOperator = this.getParsedOperator(strVal2); // TODO - use value directly (maybe)\n    const parsedTimeValue2 = this.getParsedTime(strVal3);\n    \n    if (!parsedTimeValue1 || !parsedOperator || !parsedTimeValue2) {\n      return null;\n    }\n\n    parsedExpressionArray.push(...[parsedTimeValue1, parsedOperator, parsedTimeValue2]);\n    \n    // Determine expression type\n    let expressionType;\n    if (parsedExpressionArray[0]?.type === TimeType.DURATION && parsedExpressionArray[2]?.type === TimeType.DURATION && parsedExpressionArray[1] !== TimeOperator.TO) {\n      expressionType = OperationType.DURATION_AND_DURATION;\n    } else if (\n      parsedExpressionArray[0]?.type === TimeType.TIMESTAMP && parsedExpressionArray[2]?.type === TimeType.TIMESTAMP && parsedExpressionArray[1] === TimeOperator.TO\n    ) {\n      expressionType = OperationType.POINT_TO_POINT;\n    } else if (\n      parsedExpressionArray[0]?.type === TimeType.TIMESTAMP && parsedExpressionArray[2]?.type === TimeType.DURATION && parsedExpressionArray[1] !== TimeOperator.TO \n    ) {\n      expressionType = OperationType.POINT_AND_DURATION;\n    } else {\n      return null; // invalid expresion detected.\n    }\n\n    return {\n      expression: parsedExpressionArray as [Time, TimeOperator, Time],\n      type: expressionType,\n    }\n  }\n\n  // Takes the ms output from TimeMath.evaluate and converts to string value that can be shown to user\n  public formatOutput(time: Time): string {\n    const { value: timeVal, type } = time;\n    if (type === TimeType.DURATION) {\n      return this.formatDurationOutput(timeVal);\n    }\n\n    return this.formatTimestampOutput(timeVal);\n  }\n\n  /*\n  * strVal examples: \"5hr\", \"30min\", \"5hr30min\"\n  * returns duration in ms\n  */\n  public getDuration(strVal: string): number {\n    let hoursStr = '';\n    let minutesStr = '';\n    let valueStr = '';\n\n    // \"hr\" \"min\" -- skip \"r\" \"i\" and \"n\" chars - just use \"h\" and \"m\"\n    const skipChars = ['r', 'i', 'n'];\n\n    for (let char of strVal) {\n      if (digitOnlyRegex.test(char)) {\n        valueStr += char;\n        continue;\n      }\n\n      if (char === 'h') {\n        hoursStr = valueStr;\n        valueStr = '';\n        continue;\n      }\n\n      if (char === 'm') {\n        minutesStr = valueStr;\n        valueStr = '';\n        continue;\n      }\n\n      if (skipChars.includes(char)) {\n        continue;\n      }\n    }\n\n    const hours = hoursStr.length ? parseInt(hoursStr) * HOUR : 0;\n    const minutes = minutesStr.length ? parseInt(minutesStr) * MINUTE : 0;\n    return hours + minutes;\n  }\n\n  /*\n  * strVal examples: \"5:00\", \"5:00pm\"\n  * \"am/pm\" will only be included if is24hrTime === false\n  * returns UTC timestamp in ms for the time TODAY.\n  */\n  public getTimestamp(strVal: string): number {\n    let isPM = false;\n    let timeOnlyStr;\n    const today = new Date(Date.now());\n    if (strVal === 'now') {\n      return today.getTime();\n    }\n\n    if (!this.is24hrTime) {\n      if (strVal.indexOf('pm') > -1) {\n        isPM = true;\n      }\n      timeOnlyStr = strVal.replace(/am|pm/g, ''); // remove 'am' or 'pm' if is24hrTime === false\n    } else {\n      timeOnlyStr = strVal;\n    }\n\n    const timeStrArray = timeOnlyStr.split(':');\n    let hours = parseInt(timeStrArray[0]);\n    // Correction needed for 12:xx am -ie 00:xx in 24hr time\n    if (hours === 12 && !isPM && !this.is24hrTime) {\n      hours = 0;\n    }\n    // 12:xxpm is the same as 12:xx in 24hr time\n    if (hours !== 12 && isPM) {\n      hours += 12;\n    }\n    let minutes;\n    if (timeStrArray.length > 1) {\n      minutes = parseInt(timeStrArray[1]);\n    } else {\n      minutes = 0; // If minutes are omited from strVal (eg 12pm) set to 0.\n    }\n    \n    today.setHours(hours, minutes);\n    return today.getTime();\n  }\n\n  // ie 04:00:00 - invalid, 5hr5 - invalid, 14:00pm - invalid\n  public getTimeType(str: string): TimeType | null {\n    if (str.includes('hr') || str.includes('min')) {\n      return this.isValidDurationStr(str) ? TimeType.DURATION : null;\n    } else {\n      return this.isValidTimestampStr(str) ? TimeType.TIMESTAMP : null;\n    }\n  }\n\n  public isValidTimestampStr(timeStr: string): boolean {\n    const tokens = convertStrToTokens(timeStr); // TODO: refactor to use tokens directly\n\n    if (tokens.length === 1 && tokens[0] === 'now') {\n      return true;\n    }\n\n    if (tokens.includes('hr') || tokens.includes('min')) {\n      return false;\n    }\n\n    // Sections: <hours>:<minutes><after (am/pm)>\n    let hours = '';\n    let minutes = '';\n    let after = '';\n    let addToSection = 'hours';\n    let colonCount = 0;\n    for (let token of tokens) {\n      if (token === ':') {\n        addToSection = 'minutes';\n        colonCount++;\n        continue;\n      }\n      if (token === 'am' || token === 'pm') {\n        addToSection = 'after'\n      }\n      if (addToSection === 'hours') {\n        hours += token;\n      }\n      if (addToSection === 'minutes') {\n        minutes += token;\n      }\n      if (addToSection === 'after') {\n        after += token;\n      }\n    }\n\n    if (colonCount > 1) {\n      return false;\n    }\n    \n    if (hours.length > 2 || hours.length < 1) {\n      return false;\n    }\n    \n    // do not allow \"12:pm\"\n    if (colonCount > 0 && minutes.length !== 2) {\n      return false;\n    }\n    \n    if (this.is24hrTime && after.length > 0) {\n      return false;\n    }\n\n    if (!this.is24hrTime && (after !== '' && after !== 'am' && after !== 'pm')) {\n      return false;\n    }\n\n    const hoursToInt = parseInt(hours);\n    if (minutes === '') {\n      // if the minutes section is missing we can assume the user omitted it.\n      // Examples: 12pm, 5 (for 5:00 in 24hr time).\n      minutes = '0';\n    }\n    const minutesToInt = parseInt(minutes);\n\n    if (isNaN(hoursToInt) || isNaN(minutesToInt)) {\n      return false;\n    }\n\n    if (this.is24hrTime && hoursToInt > 23) {\n      return false;\n    }\n\n    if (!this.is24hrTime && (hoursToInt > 12 || hoursToInt < 1)) {\n      \n      return false;\n    }\n\n    if (minutesToInt > 59) {\n      return false;\n    }\n  \n    return true;\n  }\n  \n  public isValidDurationStr(timeStr: string): boolean {\n    const tokens = convertStrToTokens(timeStr); // TODO - use tokens directly\n\n    if (tokens.includes(':')) {\n      return false;\n    }\n\n    const values = [];\n    const units = [];\n\n    let value = '';\n    for (let token of tokens) {\n      if (token === 'hr' || token === 'min') {\n        values.push(value);\n        value = '';\n        units.push (token);\n        continue;\n      }\n\n      value += token;\n    }\n\n    if (value.length > 0) {\n      return false;\n    }\n\n    if (values.length > 2) {\n      return false;\n    }\n\n    for (let val of values) {\n      if (isNaN(parseInt(val))) {\n        return false;\n      }\n      // disallow leading zeros in duration values\n      if (val.length > 1 && val[0] === '0') {\n        return false;\n      }\n    }\n\n    if (units.length === 2 && (units[0] !== 'hr' || units[1] !== 'min')) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public formatDurationOutput(duration: number): string {\n    let negativeSign = '';\n    if (duration < 0) {\n      negativeSign = '-';\n      duration = Math.abs(duration);\n    }\n    const hours = Math.floor(duration / HOUR);\n\n    const remainder = duration % HOUR;\n    const minutes = Math.floor(remainder / MINUTE);\n\n    const hoursSubstr = hours > 0 ? `${hours}hr` : '';\n    const minutesSubtr = minutes > 0 ? `${minutes}min` : '';\n\n    if (!(hoursSubstr + minutesSubtr).length) {\n      return '0';\n    }\n\n    return negativeSign + hoursSubstr + minutesSubtr;\n  }\n\n  public formatTimestampOutput(timestamp: number): string {\n    const date = new Date(timestamp);\n\n    let hours = date.getHours();\n    const minutes = date.getMinutes();\n    const minutesStr = minutes < 10 ? '0'.concat(minutes.toString()) : minutes.toString();\n\n    if (this.is24hrTime) {\n      const hoursStr = hours < 10 ? '0'.concat(hours.toString()) : hours.toString();\n      return `${hoursStr}:${minutesStr}`;\n    }\n\n    let suffix = 'am';\n    if (hours > 12) {\n      suffix = 'pm';\n      hours = hours - 12;\n    } else if (hours === 0) {\n      hours = 12;\n    } else if (hours === 12) {\n      suffix = 'pm';\n    }\n    \n    return `${hours}:${minutesStr}${suffix}`;\n  }\n\n  private parseTokens(tokens: string[]): string[] | null {\n    const terms = [];\n    let currentTerm = '';\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (OPERATOR_TOKENS.includes(token)) {\n        terms.push(currentTerm);\n        terms.push(token);\n        currentTerm = '';\n      } else {\n        currentTerm += token;\n      }\n    }\n    if (currentTerm.length) {\n      terms.push(currentTerm);\n    }\n    if (terms.length !== 3) {\n      return null;\n    }\n  \n    if (!OPERATOR_TOKENS.includes(terms[1])) {\n      return null;\n    }\n  \n    return terms;\n  }\n\n  private getParsedTime(timeStr: string): Time | null {\n    const type = this.getTimeType(timeStr);\n    if (type === TimeType.DURATION) {\n      return {\n        value: this.getDuration(timeStr),\n        type,\n      }\n    }\n  \n    if (type === TimeType.TIMESTAMP) {\n      return {\n        value: this.getTimestamp(timeStr),\n        type,\n      }\n    }\n  \n    return null;\n  }\n  \n  private getParsedOperator(operatorStr: string): TimeOperator | null {\n    switch (operatorStr) {\n      case '+':\n        return TimeOperator.PLUS;\n      case '-':\n        return TimeOperator.MINUS;\n      case 'to':\n        return TimeOperator.TO;\n      default:\n        return null;\n    }\n  }\n}","import React from 'react';\nimport styled from 'styled-components';\nimport { tokenToString } from '../../timeUtils/time-parser';\n\ninterface Props {\n  inputValue: string[];\n  outputValue: string;\n}\n\nexport const Display: React.FC<Props> = ({ inputValue, outputValue }) => {\n  return <DisplayWrapper>\n    <DisplayInput type=\"text\" value={tokenToString(inputValue)} onChange={() => {}}/>\n    <DisplayOutput>{outputValue}</DisplayOutput>  \n  </DisplayWrapper>;\n}\n\nconst DisplayWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  background: #eee;\n  border-radius: 20px;\n  width: 100%;\n  height: 38%;\n`;\n\nconst BaseInput = styled.input`\n  background: none;\n  border: none;\n  padding 4px 12px;\n  &:focus {\n    outline: none;\n  }\n`;\n\nconst DisplayInput = styled(BaseInput)`\n  font-size: 2em;\n  margin-top: 10%;\n\n  @media(max-width: 375px) {\n    font-size: 1.75em;\n  }\n`;\n\nconst DisplayOutput = styled.div`\n  font-size: 1.8em;\n  padding 4px 12px;\n  display: flex;\n  justify-content: flex-end;\n  margin-bottom: 5%;\n\n  @media(max-width: 375px) {\n    font-size: 1.5em;\n  }\n`;","\nexport const BTN_GRAY = '#e1e1e1';\nexport const BTN_ORANGE = '#f2984a';\nexport const BTN_RED = '#eb5757';\nexport const BTN_GREEN = '#6fcf97';\nexport const BTN_YELLOW = '#f2c84c';\nexport const BTN_BLUE = '#56cbf2';\n\nexport const BTN_TEXT_INACTIVE = '#bdbdbd';\nexport const BTN_TEXT_ACTIVE = '#313131';\nexport const BTN_INACTIVE = '#f1f1f1';\n","import React from 'react';\nimport styled from 'styled-components';\nimport * as btnColors from '../button-colors';\n\ninterface Props {\n  updateInput: (char: string) => void;\n  toggle24hrTime: () => void;\n  is24hrTime: boolean;\n}\n\nexport const ControlButtons: React.FC<Props> = ({ updateInput, toggle24hrTime, is24hrTime }) => {\n  return <ControlButtonWrapper>\n    <TimeControlButton\n      disabled={is24hrTime} \n      isActive={!is24hrTime} \n      onClick={() => updateInput('am')}>am</TimeControlButton>\n    <TimeControlButton\n      disabled={is24hrTime} \n      isActive={!is24hrTime}\n      onClick={() => updateInput('pm')}>pm</TimeControlButton>\n    <TimeControlButton\n      isActive={is24hrTime}\n      onClick={() => toggle24hrTime()}>24hr</TimeControlButton>\n    <DurationControlButton onClick={() => updateInput('hr')}>hr</DurationControlButton>\n    <DurationControlButton onClick={() => updateInput('min')}>min</DurationControlButton>\n    <NowControlButton onClick={() => updateInput('now')}>now</NowControlButton>\n  </ControlButtonWrapper>\n}\n\nconst ControlButtonWrapper = styled.div`\n  display: grid;\n  grid-template-columns: 3fr 3fr 2fr;\n  grid-template-rows: 1fr 1fr;\n  height: 18%;\n  width: 100%;\n  column-gap: 10px;\n  row-gap: 10px;\n  padding: 10px 0;\n`;\n\nconst ControlButton = styled.button`\n  border: none;\n  border-radius: 25px;\n  font-size: 20px;\n  color: ${btnColors.BTN_TEXT_ACTIVE};\n  cursor: pointer;\n`\n\nconst DurationControlButton = styled(ControlButton)`\n  background-color: ${btnColors.BTN_YELLOW};\n`;\n\nconst NowControlButton = styled(ControlButton)`\n  background-color: ${btnColors.BTN_GREEN};\n`;\n\nconst TimeControlButton = styled(ControlButton)<{ isActive: boolean }>`\n  background-color: ${props => props.isActive ? btnColors.BTN_BLUE : btnColors.BTN_INACTIVE};\n  color: ${props => props.isActive ? btnColors.BTN_TEXT_ACTIVE : btnColors.BTN_TEXT_INACTIVE};\n`","import React from 'react';\nimport styled from 'styled-components';\nimport * as btnColors from '../button-colors';\n\nconst buttonColor = {\n  NUMBER: btnColors.BTN_GRAY,\n  OPERATOR: btnColors.BTN_ORANGE,\n  CONFIRM: btnColors.BTN_GREEN,\n  CANCEL: btnColors.BTN_RED,\n};\n\ninterface Props {\n  updateInput: (token: string) => void;\n  removeInput: () => void;\n  clearInput: () => void;\n  confirm: () => void;\n  outputValue: string;\n}\n\ninterface ButtonConfig {\n  displayString: string;\n  callback: (props: Props) => void;\n  color?: string;\n}\n\nconst ButtonsArray: ButtonConfig[] = [\n  {\n    displayString: '1',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('1');\n    }\n  },\n  {\n    displayString: '2',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('2');\n    }\n  },\n  {\n    displayString: '3',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('3');\n    }\n  },\n  {\n    displayString: 'to',\n    color: buttonColor.OPERATOR,\n    callback: ({ updateInput }) => {\n      updateInput('to');\n    }\n  },\n  {\n    displayString: '4',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('4');\n    }\n  },\n  {\n    displayString: '5',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('5');\n    }\n  },\n  {\n    displayString: '6',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('6');\n    }\n  },\n  {\n    displayString: '+',\n    color: buttonColor.OPERATOR,\n    callback: ({ updateInput }) => {\n      updateInput('+');\n    }\n  },\n  {\n    displayString: '7',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('7');\n    }\n  },\n  {\n    displayString: '8',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('8');\n    }\n  },\n  {\n    displayString: '9',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('9');\n    }\n  },\n  {\n    displayString: '-',\n    color: buttonColor.OPERATOR,\n    callback: ({ updateInput }) => {\n      updateInput('-');\n    }\n  },\n  {\n    displayString: ':',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput(':');\n    }\n  },\n  {\n    displayString: '0',\n    color: buttonColor.NUMBER,\n    callback: ({ updateInput }) => {\n      updateInput('0');\n    }\n  },\n  {\n    displayString: 'C',\n    color: buttonColor.CANCEL,\n    callback: ({ removeInput, clearInput, outputValue }) => {\n      if (outputValue.length) {\n        clearInput();\n      } else {\n        removeInput();\n      }\n    }\n  },\n  {\n    displayString: '=',\n    color: buttonColor.CONFIRM,\n    callback: ({ confirm }) => {\n      confirm();\n    }\n  },\n\n];\n\nexport const ButtonGrid: React.FC<Props> = (props) => {\n  return <ButtonGridWrapper>\n    {ButtonsArray.map((btnConfig: ButtonConfig) => {\n      if (btnConfig.displayString !== 'C') {\n        return <Button key={btnConfig.displayString} color={btnConfig.color} onClick={() => btnConfig.callback(props)}>{btnConfig.displayString}</Button>\n      } else {\n        return (\n          <BackButton key={btnConfig.displayString} color={btnConfig.color} onClick={() => btnConfig.callback(props)}>\n            {props.outputValue.length ? btnConfig.displayString : <BackSymbol></BackSymbol>}\n          </BackButton>\n        )\n      }\n      \n    })}\n  </ButtonGridWrapper>\n}\n\nconst ButtonGridWrapper = styled.div`\n  height: 45%;\n  width: 100%;\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-template-rows: repeat(4, 1fr);\n  column-gap: 10px;\n  row-gap: 10px;\n`;\n\nconst Button = styled.button`\n  border: none;\n  border-radius: 20px;\n  background: ${props => props.color};\n  font-size: 30px;\n  color: ${btnColors.BTN_TEXT_ACTIVE};\n\n  &:hover {\n    cursor: pointer;\n  }\n`;\n\nconst BackButton = styled(Button)`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst BackSymbol = styled.div`\n  width: 0; \n  height: 0; \n  border-top: 12px solid transparent;\n  border-bottom: 12px solid transparent; \n  border-right: 24px solid ${btnColors.BTN_TEXT_ACTIVE};\n  margin-right: 4px;\n`;","import React, { useState, useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport { Display } from './Display/Display';\nimport { ControlButtons } from './ControlButtons/ControlButtons';\nimport { ButtonGrid } from './ButtonGrid/ButtonGrid';\nimport { TimeParser } from '../timeUtils/time-parser';\n\nconst Calculator: React.FC = () => {\n  const [ inputValue, setInputValue ] = useState<string[]>([]);\n  const [ outputValue, setOutputValue ] = useState('');\n  const [ is24hrTime, setIs24hrTime ] = useState(false);\n\n  const timeParserRef = useRef<TimeParser>();\n  timeParserRef.current = new TimeParser(is24hrTime);\n\n  useEffect(() => {\n      timeParserRef.current?.set24hrTime(is24hrTime);\n  }, [is24hrTime]);\n\n  const handleUpdateInput = (token: string) => {\n    setInputValue(inputValue.concat(token));\n  }\n\n  const handleRemoveInput = () => {\n    setInputValue(inputValue.slice(0, -1));\n  }\n\n  const handleClearInput = () => {\n    setInputValue([]);\n    setOutputValue('');\n  }\n\n  const handleToggle24hrTime = () => {\n    setIs24hrTime(!is24hrTime);\n  }\n\n  const handleConfirm = () => {\n    if (timeParserRef.current) {\n      const output = timeParserRef.current.evaluateExpression(inputValue);\n      setOutputValue(output);\n    }\n  }\n\n  return <CalculatorWrapper>\n    <Display inputValue={inputValue} outputValue={outputValue}/>\n    <ControlButtons is24hrTime={is24hrTime} updateInput={handleUpdateInput} toggle24hrTime={handleToggle24hrTime}/>\n    <ButtonGrid \n      updateInput={handleUpdateInput}\n      removeInput={handleRemoveInput}\n      clearInput={handleClearInput}\n      confirm={handleConfirm}\n      outputValue={outputValue}\n      />\n  </CalculatorWrapper>;\n}\n\nexport default Calculator;\n\nconst CalculatorWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 400px;\n  height: 800px;\n  margin: 150px auto;\n  border-radius: 20px;\n  padding: 15px 15px 30px 15px;\n  background: #414141;\n\n  @media (max-width: 800px) {\n    margin: 0;\n    width: 100%;\n    height: 100vh;\n    border-radius: initial;\n  }\n`;\nCalculatorWrapper.displayName = 'Calculator';","import React from 'react';\nimport Calculator from './components/Calculator';\n\nconst App: React.FC = () => {\n  return <Calculator />;\n}\n\nexport default App;","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}